# Checklist



## RDBMS에 길이를 알 수 없는 배열을 저장하려면 어떻게 설계해야 할까요?

배열의 값을 가지고 별도의 테이블을 만들어야 합니다.

엑셀에서는 복합적인 값을 하나의 셀에 정의하는 일이 가능하지만, RDBMS에서는 불가능합니다. 이때 배열 데이터를 집어넣을 방법은 두 가지가 있는데, 하나는 배열의 값을 하나의 열로 추가하는 것입니다. 하지만 이 경우에는 배열의 값이 계속 추가되는 경우에 테이블의 정의도 변경해줘야만 하기 때문에, 테이블이 복잡해지고 예측하기 힘든 오류 발생의 위험을 높입니다.

그래서 배열 값을 가지고 별도의 테이블을 만들어줍니다. 이 경우 배열을 포괄하는 단어로 열의 이름을 지정해주고, 값이 추가될 때마다 해당 열 밑으로 행이 추가되면, 길이를 알 수 없는 배열에 대응할 수 있게됩니다.



 ## RDBMS 테이블의 정규화는 무엇인가요?

정규화는 데이터베이스 설계에서 규칙에 의거하여 데이터를 점진적으로 구조화하는 과정입니다. 그래서 테이블의 확장성을 높이고, 데이터가 잘 질의되고 조작할 수 있도록 만듭니다.

RDBMS에서 사용자는 자의적으로 열을 정의하거나 테이블을 나누는 게 가능합니다. 이때 어떤 기준 없이 열을 정의하고 테이블을 나누거나, 나누지 않으면 설계자 말고는 누구도 파악하기 힘든 상태가 됩니다.

그래서 '테이블은 이렇게 정의해야 한다'라는 하나의 이론이 생겨났는데, 바로 정규화입니다.

정규형은 제 1형부터 최근에는 6형까지 존재하지만, 실무에서는 제 1형부터 3형까지의 정규화선에서 해결되고, 일부 고성능 처리를 위해서 비정규화를 진행하는 경우도 있습니다.

간단하게 제 1형부터 3형까지를 살펴보겠습니다.

앞서 배열에 관한 설명을 했는데, 제 1정규형은 ''테이블 셀에 배열처럼 복합적인 값을 포함하지 않는다.' 라는 원칙을 가지고 있습니다. 하지만 RDBMS에서는 기술적으로 불가능하거나, 작성은 해도 이용할 수 없어서 사실상 대부분 제 1정규형을 자동으로 만족하고 있습니다.

제 2정규형은 제 1정규형은 만족했지만, 테이블 내의  `부분함수 종속`의 존재여부를 기준으로 만족 여부를 따집니다. 부분함수 종속이란 기본키를 구성하는 열의 일부에만 함수 종속이 존재하는 것입니다. 이 말은 A와 B라는 열의 조합이 고유한 키로서 작용할 때, A라는 키만으로 함수 종속이 성립되는 경우가 생길때 발생합니다. 그래서 A만으로 함수 종속이 성립되는 경우에 B열은 필요없는 정보가 되어버립니다. 이 경우에 부분함수 종속이 발생하지 않도록 테이블을 나눠줘야 합니다.

제 3정규형은 `추이함수종속`이 발생하는 경우가 없어야 합니다. 추이함수종속이란 기본키 이외의 키 간에 함수 종속이 발생하는 경우를 말합니다. 그래서 기본키를 A라고 했을때, A 외에 B와 C라는 두 열 간 함수 종속이 발생하고, 결론적으로는 A -> B -> C가 성립되는 형태를 추이함수종속이 발생한다고 얘기합니다. 이 경우에는 B -> C의 종속 관계를 분리해 별도의 테이블로 만들어 주어야 합니다.



## MySQL 엔진에는 어떤 것들이 있나요?

MySQL에는 서버와 스토리지 두 가지 형태의 엔진이 존재합니다.

먼저 서버엔진은 클라이언트의 요청을 받아 SQL을 처리하는 역할을 합니다. DB가 SQL을 이해할 수 있도록 쿼리를 파싱하고 스토리지 엔진에 데이터를 요청하는 작업을 합니다.

두 번째는 스토리지 엔진입니다. 스토리지 엔진은 필요한 데이터를 물리적 장치에서 가지고 오는 역할을 합니다. 데이터를 어떻게 저장하고 접근할 것인지에 대한 기능을 제공하기 때문에, 여러가지 종류의 스토리지 엔진이 있고, 각각 특징과 알맞은 용도를 가지고 있습니다.

스토리지 엔진은 대표적으로 MyISAM과 InnoDB로 나눌 수 있습니다.

먼저 MyISAM은 예전에 MySQL의 기본 스토리지 엔진이었고,인덱스와 키만 메모리에 적재해서 사용하는 방식을 가지고 있습니다. 데이터 저장에 제한이 없고 효율적으로 저장해서 속도가 빠른편입니다. 다만 트랜잭션을 지원하지 않고 테이블 단위의 Lock을 지원하기 때문에, 여러 세션에서 데이터를 변경하려고 하면 성능 저하가 일어납니다. 결론적으로 읽기 성능은 좋으나 쓰기가 빈번한 경우에 부적합합니다.

InnoDB는 현재 MySQL의 기본 스토리지 엔진입니다. MyISAM과 다르게 트랜잭션을 지원하고, Row 레벨의 락을 지원합니다. 그래서 테이블을 작업할 때, 작업하는 열 외에는 다른 사용자가 수정을 할 수 있습니다. 이 말은 쓰기 작업에 용이함을 의미하고, 데이터 입력이나 수정이 빈번한 경우에 적합합니다.



## RDBMS에서 테이블의 인덱싱은 무엇인가요? 인덱싱을 하면 어떤 점이 다르며, 어떤 식으로 동작하나요?

인덱싱은 데이터에 키를 붙여서, 데이터 탐색의 효율성을 증가시키는 방법입니다.

RDBMS는 임의의 쿼리를 받을때, 이 쿼리를 파싱하고, 필요한 데이터에 어떻게 접근할 것인지에 대한 계획을 세웁니다. 이 계획을 실행계획이라고 하는데, 실행계획은 옵티마이저가 결정합니다.

이때 테이블에 액세스 하는 방법은 `풀 스캔`과 `레인지 스캔` 2가지가 있습니다. 풀 스캔의 경우 말 그대로 레코드를 처음부터 끝까지 읽는 방법이고, 레인지 스캔은 일부 레코드에만 접근하는 방법입니다.

데이터가 방대해지면 당연히 처음부터 끝까지 읽는 것보다 일부만을 읽는 게 효율적인 경우가 생길 것입니다. 이때 레인지 스캔을 하기 위해서는 인덱스가 필요합니다. 키워드가 어디에 존재하는지 판별할 요소가 필요하기 때문입니다.

따라서 인덱싱을 하면 SQL 문의 변경 없이 성능을 개선할 수 있고, 테이블의 데이터에도 영향을 주지 않습니다. 즉 비용 대비 효율이 높은 방법입니다.

인덱스는 B-tree 구조로 되어있습니다. B-tree는 순서를 유지하고 있는 데이터로 되어있는데, 값의 대소를 비교해서 분기에 들어가는 이진 탐색의 형태로 되어있습니다. 그래서 어떤 값에 대해서도 같은 시간의 결과를 얻을 수 있고, 균일성이 좋다고 표현합니다. 어떤 자료에 대해서도 균형 잡힌 성능을 보장합니다.

다시 풀 스캔과 비교하자면, 풀 스캔은 선형 탐색이기 때문에 데이터 양에 비례해서 처리시간도 크게 늘어납니다. 반대로 B-tree 인덱스는 이진 탐색의 형태이기 때문에 풀 스캔에 비교해서 완만한 곡선을 그리게 됩니다.



## DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?

DB에는 데이터를 암호화 하는 함수가 존재하기 때문입니다. 사용자의 암호가 평문으로 저장돼있지 않더라도, 입력 값을 암호화하여 DB에 들어있는 암호화 돼 있는 비밀번호랑 비교 할 수 있습니다. 혹은 저장된 암호문을 복호화하여 인증하는 방법도 있습니다.



## Quest

``` mysql
CREATE TABLE User (
	id CHAR(20) NOT NULL,
  pw VARCHAR(20) NOT NULL,
  nickname VARCHAR(10) NOT NULL,
  PRIMARY KEY(id)
);

CREATE TABLE Notepad (
	id INT NOT NULL AUTO_INCREMENT,
 	created DATETIME NOT NULL,
  modified DATETIME NOT NULL,
  title VARCHAR(30),
  description MEDIUMTEXT,
  user_id CHAR,
  PRIMARY KEY(id)
  FOREIGN KEY(user_id)
  	REFERENCES User(id)
);
```

