# Checklist

## Node.js는 어떤 식으로 동작하나요?

Node.js는 `libuv`라는 비동기I/O 처리 라이브러리 위에서 동작합니다. libuv에는 메인스레드이자 싱글스레드로 비즈니스 로직을 처리하는  `이벤트 루프` 와, OS와 이벤트 루프 사이에서 동작하는 uv_io가 있습니다.

개발자가 node.js 로직을 작성하면 node.js API는 해당 코드와 V8 엔진을 받아 이벤트 루프의 파라미터로 넘깁니다. 이벤트 루프는 넘겨 받은 `v8::Isolate` 와 `v8::Context` 를 이용해서 자바스크립트 로직을 처리합니다. 처리하는 도중에 블로킹 I/O 작업을 만나면 uv_io에 있는 워커 쓰레드로 넘겨주거나 uv_io를 통해 OS 영역(커널 비동기)로 넘겨줍니다. 완료된 작업은 다시 이벤트루프의 콜백으로 등록됩니다. 기본적으로 싱글 스레드인 이벤트 루프에서 대부분의 일을 처리하기 때문에, 이벤트 루프가 블로킹되지 않게 해야합니다.

이벤트 루프는 여러가지 phase로 구성돼있습니다. 각 phase는 FIFO 큐로 동작하고, 이 큐 안에 특정 이벤트의 콜백을 넣고, 해당 phase를 호출 할 때 실행됩니다.

- **timers:** `setTimeout()` 과 `setInterval()` 로 스케줄링한 콜백을 실행합니다. 우리는 코드 상에서 작성할 때, 지정한 타이밍에 실행되기를 원하지만, 내부에서는 일정 시간 후에 실행되어야 하는 `기준 시간` 을 지정하는 역할을 합니다. 지정 시간 이후에 가능한 빠른 시간 안에 실행되는데, 운영체제 스케줄링이나 다른 콜백 실행으로 지연될 수 있기 때문에 항상 의도하는 타이밍을 보장하지 않을 수 있습니다
- **pending:** 이 페이즈에서는 시스템 관련 콜백을 처리합니다. 예를들어 노드 서버 코드를 작성하면서 포트 번호를 입력해 줍니다. 그런데 이 포트 번호가 다른 프로세스에서 이미 사용 중인 경우를 생각해보겠습니다. node는 `ECONNREFUSED`라는 에러를 내뱉습니다. *nix 시스템 중 일부는 다른 작업을 처리하고 싶어서, 해당 콜백이 기다리기를 원할 수도 있습니다. 이런 기다리는 콜백을 실행하기 위해서 pending callback queue에 넣어 놓습니다
- **idle, prepare:** 이벤트 루프 내부 용도로 사용합니다
- **poll:** 새로운 I/O 이벤트를 가져와서 처리합니다. 클로즈 콜백, 타이머로 스케줄링 된 콜백, `setImmediate()` 를 제외한 거의 모든 콜백을 실행합니다. 이 페이즈에서는 크게 두 가지 일을 합니다.
  1. poll 페이즈의 queue에 이미 콜백이 존재한다면, 모든 콜백이 큐에서 제거될 때 까지 실행합니다
  2. queue에 콜백이 없는 경우 이벤트 루프는 잠깐 대기하고 다음 단계로 넘어가는데, 해당 대기를 결정하는 상황은 아래와 같습니다
     - 실행해야 하는 setImmediate가 존재하면 바로 다음 페이즈인 check로 이동합니다
     - poll 페이즈에서 만료된 타이머가 있는 것을 인지하고, 해당 콜백의 실행을 기다리고 있는 경우, timer 콜백으로 돌아갑니다
- **check:** `setImmediate()` 콜백이 호출되는 영역입니다
- **close callbacks:** 클로징 이벤트와 관련한 콜백을 처리합니다



setTimeout과 setImmeidate API를 이용한 간단한 코드 예시를 보겠습니다.

``` js
function cb() {
  setTimeout(() => { console.log('1') }, 0);
  setImmediate(() => { console.log('2') });
}

cb();
```

node에서 해당 함수를 실행하면, 이벤트 루프는 timers 페이즈에 진입합니다. 먼저 setTiemout의 콜백을 실행하고 다음 페이즈에 실행할 콜백이 없으면, check 페이즈까지 가서 setImmediate 콜백을 실행하게 됩니다.

여기서 결과 값이 1, 2 혹은 2, 1의 역순으로 매 번 상이하게 나올 수 있는데, 이유는 위에서 언급한 것 처럼 의도하는 타이밍을 보장하지 않기 때문입니다.

poll 페이즈에서 타이머의 실행 시점을 제어히기 때문에, 콜백 함수가 많거나 대기에 걸리는 시간으로 인해 timers 페이즈로 바로 돌아가지 않을 수 있습니다. 이런 경우 check 페이즈로 넘어가기 때문에 결과 값이 2, 1의 순으로 나오게 됩니다.

이 흐름을 바꿀 수 있는 방법이 두 가지 정도 존재합니다.

첫 번째는 다른 api의 콜백함수로 wrapping 하는 방법입니다.

``` js
function cb() {
  fs.readFile('./test.txt', () => {
    setTimeout(() => { console.log('1') }, 0);
		setImmediate(() => { console.log('2') });
  })
}

cb();
```

해당 함수는 무조건 2, 1의 순으로 출력됩니다. fs.readFile의 콜백 함수는 위에 언급한 예외사항에 속하지 않기 때문에 처음에 poll 페이즈에 추가됩니다. 그리고 fs.readFile의 콜백 함수를 처리할 때 poll 페이즈에 머물러 있는 상태에서 setImmediate 콜백이 있기 때문에 바로 다음 페이즈인 check 페이즈로 이동하여 처리하게 됩니다. 그래서 처음에 2라는 숫자가 찍히고 이후에 동일한 iteration으로 setTimeout을 처리합니다.

다른 경우는 `process.nextTick`으로 실행 흐름을 조작하는 경우입니다. process.nextTick은 이벤트 루프의 현재 페이즈와는 무관하게 완료되고 처리됩니다. 이벤트 루프가 진행되기 전에 작업을 완료하기 때문에, 이 API를 재귀로 호출하면 poll phase로 가는 것을 막아 다른 코드를 정상적으로 처리하지 못할 수도 있습니다.

콜백함수를 받고, 콜백함수에서 임의의 변수를 호출하는 함수가 있다고 가정해보겠습니다. 변수 값의 할당이 함수 호출 이후에 발생하고, 콜백함수에서 실제로 비동기적인 처리로 임의의 변수를 호출하지 않는다면, 해당 콜백함수는 할당 이전의 값을 호출하게 됩니다.

이 때 nextTick을 사용하면 변수나 함수 등의 호출이 먼저 초기화 된 이후 nextTick에 넘긴 콜백함수를 실행하게 만들 수 있습니다. 결론적으로 node.js는 API는 항상 비동기여야 한다는 설계 철학 때문에, nextTick과 같은 기능으로 실행 흐름을 제어할 수단을 남겨둔 것으로 볼 수 있습니다.



### `require()' 함수는 어떻게 쓰는 것인가요?

``` js
const module = require('./module.js')
```

require 함수의 인자로 스트링 타입의 경로를 넣어서 해당 경로에 존재하는 모듈을 받고 변수에 할당하여 사용합니다.

내장 함수인 `require`는 분리된 파일에 존재하는 모듈을 포함하는 가장 쉬운 방법입니다. `require`는 자바스크립트 파일을 읽고 파일을 실행하고, `exports` 객체를 반환하도록 처리합니다.

### import와 require의 차이

import와 require의 가장 큰 차이는 동적 리로딩의 가능 여부입니다.

require는 동적으로 모듈을 불러올 수 있습니다. 함수 안에서 정의될 수 있어서, 때로는 유용하게 사용할 수 있습니다. 다만 언제 호출될지 모르기 때문에 분석기가 이 모듈이 실제로 호출돼서 사용했는지 아닌지를 판단하기 어려워집니다. 이 문제는 웹팩의 트리-쉐이킹에 영향을 줍니다. 트리-쉐이킹은 어떤 모듈을 불러올 때, 모듈 안에서 사용하지 않는 부분은 제거해서 번들 파일의 사이즈를 줄이는 역할을 합니다. 정적 분석기가 모듈의 호출 여부를 판단하는데, 동적으로 모듈을 불러올 경우 호출 여부를 정확하게 파악하지 못합니다. 따라서 트리-쉐이킹이 제대로 동작하지 않을 확률이 높아집니다.

이 문제를 해결한 것이 import 입니다. import는 문법 자체에서 동적으로 모듈을 불러오는 일을 허락하지 않습니다. 그래서 정적 분석기는 해당 모듈의 사용 여부를 쉽게 판단할 수 있고, 사용하지 않은 모듈은 제거되어 번들 파일의 사이즈를 최적화하는데 도움을 줍니다.


### `module.exports`와 `exports` 변수는 어떻게 다른가요?

`exports`는 `module.exports`를 참조하는 변수입니다. 그래서 module.exports에는 새로운 객체를 할당해주지만, exports는 `dot notation`으로 객체에 접근해 프로퍼티를 할당해 줍니다.

``` js
module.exports = {
	...
}
  
exports.greeting = ...
```

따라서 exports의 경우 개별 함수나 변수 등을 내보낼 때 사용하고, module.exports는 객체를 새로 만들어서 내보낼 때 사용하기를 권장합니다.



## npm이 무엇인가요?

npm은 여러 소프트웨어를 보관하는 저장소 같은 것입니다. npm은 `website`, `CLI`, `registry` 세 가지로 이루어져 있습니다.

먼저 website에서 패키지를 발견하고 profile을 설정합니다. 그리고 이 패키지를 관리할 수 있습니다. 예를들어서 개인이나 공용 패키지에 대한 접근 권한을 관리할 조직을 설정할 수도 있습니다.

CLI는 터미널에서 실행하는데, npm이 제공하는 명령어를 바탕으로 패키지에 관한 처리를 할 수 있습니다.

registry는 자바스크립트 소프트웨어와 이에 관한 메타 정보를 포함하는 방대한 데이터베이스 입니다.

추가한 패키지들은 package.json 이라는 파일로 관리됩니다. package.json에는 패키지의 이름, 버전과 기타 여러가지 정보들이 들어있습니다.

결론적으로 상기의 세 가지 구성을 토대로, 개발자는 다른 개발자가 개발한 자바스크립트 라이브러리를 설치하고 사용하고 관리할 수 있습니다. 그리고 웹사이트를 이용해 패키지를 받아오기 때문에, 해당 패키지에 대한 정보 파일만 있으면, 다른 사용자도 손쉽게 동일한 패키지 구성을 설정할 수 있습니다.

### npm 패키지를 `-g` 옵션을 통해 Global로 저장하는 것과 그렇지 않은 것은 어떻게 다른가요?

-g 옵션은 해당 패키지를 전역으로 설치한다는 의미입니다. -g 옵션과 함께 설치한 패키지는 node가 접근할 수 있는 곳이라면 어디든지 사용할 수 있게됩니다.

-g 옵션 없이 설치하는 경우, npm 명령을 실행한 터미널상의 현재 디렉토리에 패키지가 저장됩니다. 패키지는 `node_modules`라는 폴더 안에 보관됩니다.

### NPX는 무엇이고 왜 사용하나요?

NPX는 NPM package 실행 도구입니다. 노드가 실행할 수 있는 것이라면 어떤 것이든 쉽게 설치할 수 있도록 해줍니다.

NPX는 로컬이나 전역에 설치하지 않고, 바로 패키지를 사용하거나 패키지를 실험해보고 싶을 때 사용할 수 있습니다. 이러한 경우에 npx를 이용하면 패키지를 바로 실행합니다.

NPX를 이용해서 패키지를 실행시키면, 로컬이나 글로벌 registry에서 해당 패키지를 찾고 실행합니다. 패키지가 설치가 돼있지 않다면, 다운로드 받고 설치하게 되는데, 저장하는 개념이 아니라 캐싱합니다. 그래서 작업이 끝난 후에 해당 패키지를 찾을 수 없습니다.
---

