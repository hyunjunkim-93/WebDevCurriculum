# Quest 09. What is server

## Checklist

### 인터넷은 어떻게 동작하나요? OSI 7 Layer에 입각하여 설명해 보세요

---

인터넷은 데이터 패킷을 주고 받는 행위에 의해 동작합니다. 이 데이터 패킷은 규약에 따라 라우터를 거쳐 목적지에 도착합니다. 이 전달 과정에서 데이터가 유실되지 않고 효율적으로 전달할 수 있도록 여러가지 처리 과정을 거칩니다.

OSI 7 Layer를 바탕으로 어떤 처리를 거쳐서 동작하게 되는지 설명해 보겠습니다. OSI 7 Layer가 선형적으로 동작하지는 않지만, 가장 사용자와 가까운 계층부터 알아보겠습니다.

한 기기에서 다른 기기로 메시지를 보내는 과정을 예시로 들어보겠습니다.

먼저 OSI 모델의 **7번째 layer인 Application layer**에서 HTTP나 FTP 같은 프로토콜을 이용해서 입력한 텍스트 데이터를 받습니다.

Application layer에서 처리한 데이터를 **6번째 레이어인 Presentation layer**에서 받습니다. 해당 데이터를 이진수로 변환하고 압축합니다. 그리고 데이터를 보낼 때는 암호화 하고, 상대방이 메시지를 받을 때는 복호화 합니다.

**5번째인 Session layer**에서 데이터 패킷과 텍스트 데이터를 mapping 하고, 패킷이 어디로 가야할지 결정합니다. 그리고 이 레이어는 서로 통신하는 기기 사이의 커뮤니케이션 설정과 관리, 종료를 맡고 있습니다.

**4번째인 Transport layer**는 session layer의 데이터를 받고 조각으로 나눕니다. 이 조각은 소스와 도착지의 port number, sequence number를 가지고 있습니다. sequence number는 이 조각들이 올바른 순서로 도착했는지 확인하는 데 쓰입니다.

이 계층은 많은 일을 하는데, 데이터의 전송량을 조정합니다. 예를 들어서 철수의 노트북은 100Mbps를 처리할 수 있는데, 영희의 노트북은 10Mbps만 처리가 가능할 수도 있습니다. 이때 Transport layer에서 서버의 데이터 전송을 느리게 조절할 수 있습니다. 반대로 영희가 메시지를 보냈을 때는, 다시 처리량을 늘려 속도를 올려줍니다.

마지막으로 에러를 검사하거나, 어떤 데이터 조각을 놓쳤을 경우, 다시 그 조각을 전송하도록 하는 역할을 합니다.

TCP와 UDP가 이 계층에서 잘 알려진 프로토콜인데, TCP는 속도보다는 퀄리티를 우선시하고, UDP는 속도를 우선시합니다.

**다음은 3번째인 Network layer** 입니다. 패킷의 형태로 네트워크 끼리 데이터 조각을 전송합니다. 메시지를 보낼 때, 데이터 조각에 소스와 목적지의 IP 주소를 할당합니다. 그리고 데이터를 전달하기 위한 최적의 경로를 설정하는 역할을 맡고 있습니다.

**2번째는 Data Link layer** 입니다. Network layer에서 패킷을 받고, Transport layer에서는 논리적인 주소 처리 작업(IPv4나 IPv6가 여기에 해당합니다)을 수행한다면, Data Link layer는 물리적인 주소를 처리하는 일을 맡고 있습니다. 여기서는 보내는 사람과 받는 사람의 MAC 주소를 데이터 패킷에 추가합니다. 이 작업을 바탕으로 프레임이라고 불리는 데이터 유닛을 형성합니다. 이 레이어에서는 프레임이 광섬유 케이블 같은 로컬 미디어를 통해 전송될 수 있도록 만들어 줍니다. 이런 일련의 작업을 위해서 이 레이어는 Network Interface Card에 소프트웨어로 내장되어 있습니다.

마지막으로 실제로 만질 수 있는 **하드웨어가 존재하는 레이어가 Physical layer** 입니다. 이 레이어는 상위 레이어에서 온 이진수를 신호로 변환하고 변환한 신호를 로컬 미디어를 통해 전송합니다. 반대로 받은 신호를 이진수로 다시 변환하는 일도 합니다.

이렇게 Physical layer를 통해 전달받은 신호를 다시 위 레이어를 거쳐 처리하게 되고, 상대방은 메시지를 볼 수 있게 됩니다.


<br>

### 우리가 브라우저의 주소 창에 www.knowre.com 을 쳤을 때, 어떤 과정을 통해 노리의 서버 주소를 알게 되나요?

---

www.knowre.com을 입력하면 DNS(Domain Name System) 서버에 IP 주소를 요청하고, 수신한 IP 주소에 해당하는 웹 서버로 접속하게 됩니다.

이 IP 주소를 알기 위해서 먼저 로컬 DNS의 캐시를 확인합니다. 이 캐시에는 최근에 방문한 웹 사이트의 IP 주소가 저장돼있습니다. 그런데 IP 주소를 찾을 수 없거나 기록이 만료된 경우에는 ISP(Internet Service Provider)의 DNS 서버에 요청하게 됩니다.

외부의 DNS 서버에 요청하기 전에 DHCP(Dynamic Host Configuration Protocol) 서버를 통해 호스트의 IP 주소와 TCP/IP 설정을 받아옵니다. DHCP에서 가져오는 IP 주소는 사용자 자신의 IP 주소뿐만 아니라 가장 가까운 라우터와 DNS 서버의 IP 주소를 받습니다. 그리고 ARP 프로토콜로 이 IP 주소를 기반으로 가장 가까운 라우터의 MAC 주소를 알아냅니다.

이제 앞서 받아온 정보를 바탕으로 DNS 서버에 도메인 이름에 대한 IP 주소를 요청합니다.  ISP의 DNS 서버에도 없다면 `.com ` 과 같이 도메인 이름의 가장 끝에 해당하는 이름인 Root Name Server에 요청 하게 됩니다.

일련의 과정을 통해 www.knowre.com의 IP 주소를 수신하게 되고, HTTP Request를 보내 응답에 대한 정보를 받게 됩니다.

<br>


## Quest

### tracert(Windows가 아닌 경우 traceroute) 명령을 통해 www.google.com 까지 가는 경로를 찾아 보세요
  * 어떤 IP 주소들이 있나요?
      * Private Network에 대한 IP 주소, 통신사업자인 LG의 IP 주소, 엔드포인트인 google에 대한 IP 주소가 있습니다
  * 그 IP 주소들은 어디에 위치해 있나요?
      * 사용자의 로컬 환경과 한국, 미국에 위치해 있습니다

### Wireshark를 통해 www.google.com 으로 요청을 날렸을 때 어떤 TCP 패킷이 오가는지 확인해 보세요
  * TCP 패킷을 주고받는 과정은 어떻게 되나요?
      * TCP는 양방향 프로토콜로 안정적으로 데이터를 처리할 수 있습니다. 이때 정확한 정보 전달을 보장하기 위해 수신측과 송신측이 통신하는 과정을 `3 way handshake`라고 부릅니다. 먼저 송신측에서 상대방과 패킷을 주고 받기를 원한다는 의미로 SYN(Synchronize Sequence Number)를 담은 Segment를 보냅니다. 수신측은 송신측의 요청에 응답하여,  SYN과 ACK(Acknowledgement)를 같이 보냅니다. 다시 이걸 받은 송신측은 수신측의 SYN 패킷을 잘 받았다는 응답으로 ACK를 다시 보냅니다. 상기의 세 과정을 통해 TCP는 신뢰성을 가지고 패킷을 주고 받습니다.
  * 각각의 패킷에 어떤 정보들이 담겨 있나요?
      * Source Port와 Destination Port
           * 데이터가 출발하는 곳과 도착해야 하는 곳을 알려주는 포트 번호가 존재합니다
      * Sequence Number
           * 데이터를 보낼 때 마다 부여되는 고유한 번호입니다. 이 번호를 통해서 중복되는 데이터는 없애고, 순서가 올바르지 않은 경우 순서대로 재구성 할 수 있습니다.
      * Acknowledgement
           * 송신자가 데이터를 보냈을 때, 정상적으로 받았다는 것을 알려주기 위한 신호입니다. 보통 수신받은 Sequence Number에 1을 더하여, 송신자에게 재송신합니다.
      * IPv4
           * 인터넷 주소를 표기하기 위한 규약입니다. 일반적으로 알고있는 `212.78.1.25` 와 같은 형태이며, 2^32 까지만 표현할 수 있어서 IPv6 같은 새로운 기준이 나온 상태입니다. 통신하기 원하는 서버의 주소를 가리킵니다.
      * 사용 프로토콜
           * 어떤 프로토콜을 사용했는지 확인할 수 있습니다. 이 경우에는 TCP(Transmission Control Protocol)가 나옵니다



### telnet 명령을 통해 http://www.google.com/ URL에 HTTP 요청을 날려보세요

* 헤더 종류와 역할
    * HTTP/1.1 200 OK
        * 사용하는 프로토콜과 버전, 요청에 대한 상태 값을 나타냅니다. 위 항목의 경우 1.1버전의 HTTP를 사용했으며, 200 OK라는 값으로 정상적으로 요청 됐음을 나타내고 있습니다
    * Date: Wed, 06 May 2020 07:15:14 GMT
        * 요청한 시점을 알려줍니다
    * Expires: -1
        * 요청한 자료에 대한 유효 날짜와 시간을 나타냅니다. 헤더의 Cache-Control에서 max-age나 s-maxage 값이 설정돼 있다면, Expires 옵션은 무시됩니다. 위 예시와 같이 유효 하지 않은 날짜 값은 자원이 이미 만료됐다는 것을 의미합니다. 아래 Cache-Control에서 max-age가 설정됐기 때문에 이 옵션은 무시됩니다.
    * Cache-Control: private, max-age=0
        * 요청과 응답에 대한 캐싱 메커니즘을 위한 디렉티브를 정하기 위해 사용합니다. 캐시 능력이나 만료, 재검증과 리로딩 등과 관련된 디렉티브를 제공합니다. private의 경우 단일 사용자를 위한 응답이며, 공유 캐시에 의해 저장되지 않아야 한다는 것을 의미합니다. max-age=0은 현재 캐시가 오래됐음을 의미합니다.
    * Content-Type: text/html; charset=ISO-8859-1
        * 데이터 자원의 미디어 타입을 나타내기 위해 사용합니다. 이 경우에는 text 타입을 가리키며, 문자가 인코딩 되는 기준은 ISO-8559-1임을 나타냅니다
    * P3P: CP="This is not a P3P policy! See g.co/p3phelp for more info."
        * 사용자와 웹 사이트 간 프라이버시 정책을 관리하는 기준입니다
    * Server: gws
        * 요청을 다루는 서버의 이름을 나타냅니다
    * X-XSS-Protection: 0
        * XSS 행위가 발견됐을 때 페이지를 불러오지 않도록 합니다. 현대 브라우저에서는 이 옵션에 대해서 고려하지 않아도 됩니다
    * X-Frame-Options: SAMEORIGIN
        * `clickjacking` 공격을 막아주고, 콘텐츠가 다른 사이트에 내장돼 있는 것이 아닌지 보장하는 역할을 합니다. SAMEORIGIN 옵션의 경우 페이지의 origin이 같은 경우에만 페이지를 보여줍니다
    * Set-Cookie
        * 서버가 유저에게 쿠키를 보내는 용도로 사용합니다
    * Accept-Ranges
        * 부분 요청 자원의 범위를 지정해서 알리는 역할을 합니다
    * Vary: Accept-Encoding
        * 캐시된 응답을 찾아서 향후에 새로운 헤더를 요청하는 것 대신에, 사용할 수 있는지 결정합니다. 상기의 옵션에서는 브라우저의 요청에 따라서 페이지에 캐시된 다른 정보들을 제공할 수 있게 해줍니다
    * Transfer-Encoding: chunked
        * 사용자에게 개체를 안전하게 전송하기 위해서 사용하는 인코딩 형식을 지정합니다. chunked 옵션은 데이터가 일련의 청크 내에서 전송됩니다