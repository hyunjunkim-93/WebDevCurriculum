# Checklist

## 어떠한 자바스크립트 코드가 HTTP 응답이나 사용자의 이벤트 등에 종속되어 언제 실행되어야 할 지 알기 어려울 때엔 어떻게 해야 할까요?

비동기 처리를 위한 방법을 사용합니다. 콜백 함수나 프로미스로 준비된 시점에서만 동작하도록 만들어줍니다. 자바스크립트는 기본적으로 비동기로 코드를 처리하기 때문에, 특정 로직의 실행을 기다려주지 않습니다. 그래서 언제 실행되어야 할 지 어려운 코드는 처리 결과를 보장받기 어려워지는데, 이런 경우를 해결하기 위해 콜백 함수를 이용한 방법과 프로미스 객체가 존재합니다.

예를들어 가려는 식당이 줄이 길어서 기다려야 하는 상황을 가정해보겠습니다. 우리는 언제 식당에 들어가야할지 모르고, 그냥 식당 앞에서 기다려야합니다. 하지만 대기자 명단에 이름을 적으면, 차례가 됐을 때 연락을 해줍니다. 즉 우리는 코드의 원래 목적을 달성하기 위해 계속 기다릴 필요 없이 실행되어야 하는 시점(콜백 함수가 호출되는 시점)이 되면 연락을 받고 식당에 입장할 수 있습니다.




## 브라우저의 `XMLHttpRequest` 객체는 무엇이고 어떻게 동작하나요?

`XMLHttpRequest`는 2006년에 W3C에서 발표한 객체 형태의 브라우저 내장 API입니다. 브라우저와 서버 사이에서 데이터를 전송하는 메서드를 가지고 있고, 브라우저의 자바스크립트 환경에서 동작합니다. 그래서 원하는 시점에서 자바스크립트 코드로 HTTP 요청을 전달할 수 있고, 클라이언트는 페이지를 새로고침 하지 않은 상태에서 서버의 데이터를 받아올 수 있습니다. 이름과 다르게 꼭 HTTP 프로토콜에서 동작하는 것은 아니며, 데이터 포맷이 XML일 필요도 없습니다.

XMLHttpRequest는 생성자 함수로 새로운 XMLHttpRequest를 만들어서 사용합니다.

``` js
const client = new XMLHttpRequest();
```

새 객체가 생성됐을 때, XMLHttpRequest 객체의 메서드를 통해 열려있는 상태일때는 가비지 콜렉티드 되지 않습니다.

요청은 크게 세 가지 메서드를 통해 이루어집니다.

1. client.open(method, URL, [async, user, password])

   이름이랑 다르게 요청에 대한 설정을 하는 메서드입니다. 인자로 메서드 타입이나 요청 URL 등을 넘깁니다

   이때 요청하는 URL과 응답하는 URL이 동일해야 합니다

2. client.send()

   설정한 값을 바탕으로 서버에 요청을 보냅니다

3. client.load - error - progress

   - load - 요청이 끝났을 때 사용합니다. 응답 값이 400번대나 500번대여도 마찬가지입니다. 그리고 응답도 완전히 받아집니다
   - error - 네트워크가 다운되거나 유효하지 않은 URL인 경우 같이 요청이 이루어지지 않았을 때 일어납니다
   - progress - 응답이 다운로드 되는 동안 정기적으로 데이터를 받아옵니다. 얼마나 많은 양이 다운로드 됐는지 알려줍니다

상기의 과정을 통해 브라우저는 서버에 데이터를 요청할 수 있습니다.





## `fetch` API는 무엇이고 어떻게 동작하나요?

`fetch`는 필요할 때 서버에 요청하고 새로운 정보를 받아올 수 있도록 만들어주는 API 입니다. XHR과의 큰 차이점은 프로미스를 사용한다는 점이고, 프로미스를 사용하기 때문에, XHR의 콜백 헬과 복잡한 API를 걱정할 필요가 없습니다. 그리고 fetch api는 쿠키나 cors 같은 설정이 가능한 반면에 XHR은 불가능합니다.

fetch()를 호출하면 네트워크 요청을 보내고 프로미스가 반환되고, 이 반환된 값을 이용해서 코드를 작성합니다. 요청에 대한 응답은 크게 두 단계를 거쳐 진행되는데, 헤더와 바디로 나눠집니다.

먼저 요청에 대한 응답 헤더를 보고 요청이 성공적으로 처리됐는지 확인합니다. 정상적으로 응답할 수 없는 상황이라면, 프로미스는 rejected 상태가 됩니다. Response 프로퍼티에서 해당 HTTP 통신의 상태를 볼 수 있습니다.

성공적으로 처리했다면, 아래와 같이 then 메서드로 다음 응답을 받고 바디의 데이터를 원하는 포맷으로 파싱해서 사용하게 됩니다.

``` js
fetch(url)
	.then(res => res.json())
	.then(data => console.log(data))
	.catch(err => console.error(err))
```

이렇게 파싱한 후 목적에 맞게 해당 데이터를 사용할 수 있게 됩니다.



### 자바스크립트의 Promise는 어떤 객체이고 어떤 일을 하나요?

`Promise` 객체는 비동기적인 작업의 최종 결과와 결과 값을 나타냅니다. 비동기 메서드가 동기 메서드처럼 값을 반환하도록 해주는 역할을 합니다. 즉시 최종 값을 반환하는 게 아니라, 좀 더 후에 결과 값을 제공하도록 하는 promise를 반환합니다. 혹은 여러개의 비동기 작업을 모두 완료하고 이후의 어떤 일을 진행하고 싶을 때 사용할 수 있는, Promise.all 같은 메서드를 지원해주기도 합니다.

간단하게 보면 프로미스는 pending - fulfilled - rejected의 세 가지 상태를 기반으로 동작합니다. 프로미스가 생성되면 pending 상태에 있다가 resolve 되면 fulfilled 상태가 되고, reject 되면 rejected 상태가 됩니다.

사용자는 정의한 작업을 promise에 넘기고, promise는 해당 작업을 비동기적으로 수행합니다. 그리고 작업의 결과물은 then 메서드를 통해서 받을 수 있고, 에러는 catch 메서드를 이용해서 처리할 수 있습니다.



### 자바스크립트의 `async`와 `await` 키워드는 어떤 역할을 하며 그 정체는 무엇일까요?

async/await은 promise처럼 비동기 메서드를 동기 메서드처럼 처리할 수 있도록 해주는 역할을 합니다. 

먼저 async는 비동기 처리가 없는 일반적인 함수가 Promise를 리턴하도록 만들어줍니다. await은 promise를 반환하는 함수가 resolve한 값을 기다렸다가 받아줄 수 있도록 합니다. 그래서 async/await을 이용하면 promise를 이용했던 것처럼 비동기 함수의 내부 코드를 동기적인 흐름으로 처리할 수 있습니다. 에러 핸들링은 try와 catch의 catch 부분으로 해결할 수 있고, 이 키워드를 사용함으로서 promise보다 코드가 간결해지고 가독성이 높아지는 효과가 있습니다.

다만 async/await만 사용하면 위에서 언급한 '여러개의 비동기 작업을 모두 완료하고 이후 어떤 일을 진행하고 싶을 때'를 처리하기가 애매해집니다. 이 부분을 해결할 수 있는 방법이 몇 개 있는데, await 뒤에 promise.all로 처리할 여러개의 비동기 작업을 받아서 구현하기도 합니다. 이렇게 할 수 있는 이유는 async/await도 결국 promise이기 때문입니다.

async와 await은 내부는 Generator와 Promise로 이루어져 있습니다. generator의 yield를 이용해서 코드를 동기적인 형태로 바꿔주고, 프로미스는 재귀적으로 호출돼서 generator로 만든 iterator를 반복해서 실행하게 됩니다. 

