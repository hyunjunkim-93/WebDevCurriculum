# QUEST.00-Review

## 서문 

### > 참고자료

- [Why does everyone use Git in a centralized manner?](https://softwareengineering.stackexchange.com/questions/315252/why-does-everyone-use-git-in-a-centralized-manner)
- [svn 능력자를 위한 git 개념 가이드]([file:///Users/junkim/Downloads/SVN%20%EB%8A%A5%EB%A0%A5%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20GIT%20%EA%B0%9C%EB%85%90%20%EA%B0%80%EC%9D%B4%EB%93%9C.pdf](file:///Users/junkim/Downloads/SVN 능력자를 위한 GIT 개념 가이드.pdf))
- [Git vs Mercurial](https://d2.naver.com/helloworld/1011)
- [Git from the Bottom Up](https://jwiegley.github.io/git-from-the-bottom-up/)
- [pro git book](https://git-scm.com/book/ko/v2)

<br>

### > 진행상황

상기의 자료를 바탕으로 Review 내용을 작성하였습니다. 해당 내용이 생각보다 쉽게 들어오지는 않아서, 점진적으로 보완해 나가겠습니다.

<br>

### > 주안점을 둔 부분

- Git과 SVN의 차이점
  - 차이점이라고 제시한 분산화의 의미를 명확히 파악하지 못했다고 생각해서, 해당 키워드를 중심으로 알아보았습니다
- Git과 Mercurial의 차이
  - 동일하게 DVCS로 분류되면서 대표적인 제품인 Git과 Mercurial이 어떤 부분에서 다른지 알아보았습니다
- Git의 동작 원리
  - 스냅샷이나 변경 사항, HEAD 같은 것들의 내부 동작 원리를 언급해주셨는데, 이해를 하려면 아예 사용되는 기본 단어부터 확실하게 알아야겠다는 생각이 들어서 위 자료를 토대로 실습해보고 있습니다

---



## Git과 SVN

SVN의 경우 보통 저장소가 서버에 있습니다. git도 보통 원격 저장소를 만들어서 작업을 하게 됩니다. 이때 git의 경우 원격 저장소의 복사본을 로컬에도 가진다는 점에서 차이가 생깁니다.

SVN은 checkout 명령어로 원격 저장소의 작업 파일 및 SVN 관련 설정들만 받아옵니다. 따라서 log 라던지 저장소의 history를 확인하려면 네트워크를 거쳐야하므로 git에 비해 속도가 훨씬 느립니다. 반면 git은 clone 명령어로 원격 저장소의 내용을 받아올때 복사본을 가져오기 때문에, 네트워크를 거칠 필요가 없이 저장소의 history를 빠른 속도로 확인할 수 있습니다.

또한 원격 저장소에 대한 복사본을 각각의 작업자가 가지고 있다는 점에서, 원격 저장소가 손상되어도 각 작업자의 로컬저장소 기준으로 복원이 가능합니다. 이런 부분은 원격 저장소 하나에 의존적인 SVN과는 대조적입니다.

Git은 SVN에 비해 작업을 의미론적으로 나눠서 하기 쉽습니다. 

이 부분은 SVN과 Git이 각각의 버전을 저장하는 방법의 차이에서 발생합니다. SVN이 각각의 파일에 대한 변화를 저장하는 반면, git은 그 순간의 스냅샷을 저장해서 버전을 구성합니다. 특정 버전을 가지고 올 때 SVN은 기본 파일과 그 파일의 모든 변경 내역을 가져와서 특정 버전을 구성하는 반면, git은 가까운 스냅샷을 가져와서 특정 버전을 구성합니다. 게다가 이전에 언급한 것 처럼 해당 작업이 네트워크를 거치지 않기 때문에 훨씬 빠릅니다.

이 부분은 브랜치를 만들 때도 똑같이 적용됩니다. SVN에서 브랜치를 생성하면, 전체 파일과 변경 내역을 네트워크로 내려받아 생성하게 됩니다. 반면 git은 commit에 의한 스냅샷이 연속적으로 이어지다가 해당 스냅샷 기준으로 분기되는 형태로 브랜치가 만들어집니다. 그래서 브랜치를 쉽게 생성하거나 삭제하고, 이동할 수 있습니다.

<br>

## Git과 Mercurial

Git과 Mercurial은 분산 버전 관리 시스템입니다. 변경 이력을 시간에 따른 선형 구조로 나타내지 않고, 복수의 부모 변경과 자식 변경을 표시하는 그래프로 나타냅니다. 다만 Git은 다수의 병렬 브랜치를 전제로 설계하고, Mercurial은 이런 부분보다는 쉽게 배우고 사용하는데 초점을 맞췄다는 차이점이 있습니다.

사용성 측면에서 Mercurial을 종합 공구 세트, Git은 맥가이버 칼에 비교하는데, 이 비유가 제 관점에서는 Mercurial은 Django, Git은 flask처럼 느껴졌습니다. Mercurial은 확장하기는 어렵지만, 필요한 대부분의 요소를 갖추고 있고, Git은 최소한의 기본적인 기능만 있지만, 확장이 쉽습니다.

내부적으로는 저장소에 대한 관리 방법과 병합 시스템에서 차이점을 가집니다.

먼저 Git의 저장소는 스냅샷 기반이고 BLOB이라는 오브젝트에서 그 내용을 관리하는데, 특정 시점의 전체 내용을 가지고 있습니다. 반면에 Mercurial은 각 파일별 변경분만 추적합니다. 변경 기록용 파일이 별도로 존재해, 대상이 되는 파일의 변경 이력을 저장합니다.  

내용 자체가 더 간소화 되어있기 때문에, Git에 비해 저장소의 크기가 완만하게 증가하고, 변경 이력만 추적하기 때문에 patch의 생성이나 변경 이력 추적도 Git보다 빠릅니다. 다만 스냅샷 생성, 업데이트, 커밋 등 더 많은 정보가 필요한 작업은 Git에 비해 더 높은 비용을 가집니다.

앞서 말했던 것처럼 Git이 다수의 병렬 브랜치를 병합하고 변경 이력을 관리하기 더욱 용이합니다. Git은 대규모 브랜치를 고려하여 설계했기 때문에, n-way 병합을 지원합니다. 반면에 Mercurial은 익명 브랜치를 기본 사양으로 2-way 병합을 기본으로 하며, 경우에 따라 N-1의 병합을 실행하게 됩니다.

(이 부분은 아직 이해가 안갑니다. 생활코딩이나 기타 문서에서는 Git의 3-way merge에 대해서 설명하고 있는데, Git vs Mercurial 문서에서는 'SVN의 단순 스냅샷 기반의 3-Way 병합에 비해 영리한 병합 작업이 가능하다' 라는 문구가 있어서, 3-way merge는 git의 특징이 아닌 것인가 하는 의문이 듭니다)

브랜치 모델을 봤을 때도, Git은 커밋에 영향을 미치지 않고 브랜치를 쉽게 생성하거나, 삭제하거나, 변경할 수 있습니다. git에서 브랜치를 생성하면 마지막 커밋을 참조하여, 새로 커밋을 생성하고 브랜치로 할당합니다. 따라서 의도했던 마지막 변경 지점과 새 브랜치의 지점이 구분됩니다. 반면 Mercurial의 브랜치는 커밋과 한 세트입니다. 새 브랜치는 해당 커밋을 포함합니다. 브랜치를 제거하는 일은 히스토리를 변경하는 일이 돼서, 주의를 기울여야 합니다.

index나 staging area도 존재하지 않아서 변경 사항이 바로 working directory에 반영됩니다. 대다수의 경우 이렇게 바로 반영되는 게 적합할수도 있지만, 만약 이런 단계적인 구분이 필요하다면 Mercurial의 경우 해당 기능을 지원해주는 extension을 별도로 설치해야 합니다.

<br>

## Git의 동작 원리

`Repository - Working Tree - Index`

1. Git은 기본적으로 Repository와 `.git` 이라는 서브 디렉토리를 포함한 Working Tree를 만들어냅니다.
2. Working Tree에서의 변경 사항은 `git add` 명령어를 통해 staging area에 추가됩니다.
3. 변경 사항은 곧바로 Repository에 반영되지 않는데, `git commit` 명령어를 통해 staging area에 있는 변경 사항을 Repository에 반영할 수 있습니다.

Git이 하는 일은 간단합니다. 디렉토리의 스냅샷을 관리합니다.

Git 레파지토리의 디자인은 UNIX의 파일 시스템 구조와 비슷한 부분이 많습니다. UNIX의 파일 시스템이 루트 디렉토리가 있고, 그 아래 다른 디렉토리, leaf-node, 데이터 등이 있는 것처럼 Git도 비슷한 구조를 가집니다.

다만 약간의 차이점이 있는데, Git은 BLOB이 파일의 콘텐츠를 포함합니다. BLOB은 leaf-node고 i-node처럼 사이즈와 콘텐츠의 SHA1 hash id를 계산해서 이름이 붙습니다. BLOB의 콘텐츠는 절대 바뀌지 않고, 같은 콘텐츠는 항상 같은 BLOB으로 나타낼 수 있습니다. 어떤 컴퓨터에서든 마찬가지입니다.

또 다른 차이는 BLOB은 스스로가 메타 데이터를 가지지 않고, BLOB을 가지고 있는 tree에서 가지고 있습니다. 그래서 tree에 저장돼있는 메타데이터는 다르지만, 콘텐츠는 같아도 같은 BLOB으로 표현합니다. 하지만 보통 파일 시스템에서는 다른 메타 데이터를 가졌지만 콘텐츠는 같은 경우 독립적인 파일로 분류합니다.

```bash
mkdir sample; cd sample
echo 'Hello, Knowre!' > greeting
```

예시로 폴더를 하나 만들고  'Knowre'라는 텍스트를 담은 파일을 생성해 보겠습니다. 레파지토리를 생성하지는 않았지만, git의 커맨드를 이용해서 hash id를 확인할 수 있습니다.

``` bash
git hash-object greeting
cd0298e30dec52d001341a7fd3f3f25c40628754
```

상기의 명령어를 입력해서 나오는 값은 어디에서나 같습니다. 다른 레파지토리에서 생성하거나 pull 받아와서 확인해봐도 값이 같게 나오는 모습을 볼 수 있을 것입니다.

이번에는 레파지토리를 생성하고 commit을 추가하면 어떤 일이 일어나는지 확인해보겠습니다.

``` bash
git init
```

상기의 명령어를 입력하면 현재 디렉토리를 루트 디렉토리로 삼아, `.git` 이라는 폴더를 생성합니다. 이 폴더에 레파지토리에 대한 정보가 저장됩니다.

지금 단계에서는 HEAD 파일을 확인하면 현재 checkout한 브랜치 정보가 나옵니다. git의 default 브랜치는 master라는 이름을 가졌기 때문에, `ref: refs/heads/master` 라고 나오는 것을 확인할 수 있습니다.

```bash
git add greeting
```

해당 파일을 staging area에 올리면 `.git`에 index라는 파일이 생겨납니다. 이 파일에서 add한 변화의 정보가 담기게 됩니다. 이어서 레파지토리에 커밋 명령어를 입력하면 최종적으로 변화가 레파지토리에 반영됩니다.

``` bash
git commit -m "Initial Commit"
```

이때는 objects 폴더에서 변화가 일어나는데, objects 폴더는 tree, BLOB, commit에 대한 정보를 각각의 폴더로 나눠서 저장합니다. 해당 hash 값은 총 40자리이며 앞 2자리는 폴더명으로 뒤 38자리는 폴더 안의 파일 이름으로 되어있습니다.

커밋은 변경 사항의 스냅샷이기 때문에, 기존 내용을 수정해도 수정한 내용의 tree, BLOB, commit 정보를 objects 폴더 안에 새로 생성합니다.

