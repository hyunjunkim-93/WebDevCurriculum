# Checklist



## 여러 개로 나뉘어진 자바스크립트나 이미지, 컴포넌트 파일 등을 하나로 합치는 작업을 하는 것은 성능상에서 어떤 이점이 있을까요?

여러 개의 파일을 불러오는 것 보다, 하나 혹은 적은 개수의 파일을 불러오는 것이 화면에 HTML 문서를 더 빨리 렌더할 수 있습니다.

웹에서 클라이언트와 서버의 통신은 HTTP로 이루어집니다. 서버에는 자바스크립트나 HTML, 이미지 파일 등이 저장돼 있고, 클라이언트는 이 파일을 HTTP를 통해 요청하고 받아옵니다.

기본적으로 어떤 페이지를 렌더링 하기 위해 여러 개의 파일을 요청해야 한다면, HTTP는 파일의 수 만큼 요청을 반복하게 됩니다. 이 방법은 하나의 파일을 요청하는 것 보다 시간이 오래걸립니다.

시간이 오래 걸리는 이유는 HTTP의 요청-응답 시스템과 압축 알고리즘 때문입니다. 

대부분의 웹페이지는 HTTP 1.1버전과 2.0버전을 사용합니다.

HTTP1.1은 기본적으로 이전 요청에 대한 응답이 반환된 후에 다음 요청을 보냅니다. 따라서 앞에서 설명한 것 처럼 딸려있는 파일의 수만큼 라운드를 돌게 됩니다. 파일이 많을 수록 시간은 당연히 오래 걸리기 때문에, 좀 더 로딩 시간을 줄이고자 pipelining이라는 테크닉이 나오게 되었습니다.

HTTP1.1의 pipelining은 여러 번의 HTTP 요청을, 상응하는 응답 값을 기다릴 필요 없이 하나의 TCP 커넥션에서 보내는 방법입니다. 취지는 좋았지만 HTTP1.1의 제한이 여전히 적용됐고, 서버는 요청 순으로 다시 응답 값을 보내야만 했습니다. 이때문에 전체 연결은 FIFO 형태로 남아있었고, HOL blocking이 발생했습니다.

(HOL blocking은 패킷의 라인성능이 제한되는 현상입니다. 브라우저에서 허용한 병렬 요청의 수가 초과됐을 때, 다음 요청은 이전 요청이 완료될 때까지 기다려야 합니다)

HTTP 2.0의 multiplexing과 SPDY에서 이 문제를 어느정도 해결했습니다. 특히 HTTP 2.0의 multiplexing으로 더 이상 파일 등을 하나로 합쳐서 번들링 할 필요가 없다는 얘기가 떠돌기도 했습니다. 그래도 여전히 하나 혹은 소수의 파일로 합치는 작업이 더욱 좋은 성능을 보여줍니다.

(SPDY는 Software Package Data Exchange로 현재는  HTTP 2.0 발표로 deprecated인 네트워크 프로토콜입니다 압축과 우선순위, 멀티플랙싱을 이용해서 레이턴시를 줄여주는 역할을 합니다)

이유는 HTTP2.0의 압축 성능이 아직 안좋기 때문입니다. 압축 알고리즘의 특성에 따라서 여러 개의 작은 파일을 압축할 때보다, 하나의 큰 파일을 압축할 때 더 높은 효율성을 보여줍니다. 그리고 서버와 브라우저는 아직까지 동시성에 제한 기준을 가지고 있습니다.



### 이미지를 Data URL로 바꾸어 번들링하는 것은 어떤 장점과 단점이 있을까요?

Data URL로 번들링 하게되면 별도의 파일로 분리되지 않고, js 파일 안에 base64로 인코딩된 값이 추가됩니다. 파일로 분리되냐 안되냐는 번들 사이즈와 요청 회수 사이의 균형 문제라고 볼 수 있습니다.

이미지의 크기가 작은 경우에는 별도의 파일로 분리해서 요청을 한번 더 하는 게 아니라, js 파일에 인라인으로 넣는 것이 좋을 수 있습니다. 반면에 이미지 크기가 큰 경우에 js 파일의 사이즈가 과도하게 커질 가능성이 있기 때문에, 요청이 나뉘더라도 파일로 분리하는 게 좋습니다. 보통 url-loader 같은 라이브러리는 옵션을 통해서 이 사이즈를 제한합니다.



## Source Map이란 무엇인가요? Source Map을 생성하는 것은 어떤 장점이 있을까요?

Source Map은 변경된 소스를 바탕으로 원본 소스에 대한 정보를 그려낸 파일입니다.

웹 환경에서 자바스크립트 소스는 브라우저가 실행합니다. 이때 프로덕션으로 배포한 자바스크립트 소스는 효율성을 이유로 결합되거나 불필요한 부분을 줄여 작게 만들어져 있는 상태입니다. 아니면 타입스크립트로 컴파일 되어서 생성된 형태일 수도 있습니다.

그런데 프로덕션 환경에서 버그가 일어나는 경우가 종종 있습니다. 이 때 디버깅이 원활하게 가능해야 하는데, 변환된 형태의 소스 코드는 디버깅이 어렵습니다.

Source Map은 변환된 소스를 가지고 재구성한 원본 소스를 보여줍니다. 이렇게 하면 원본 소스를 보는 것 처럼 소스 코드를 살펴볼 수 있고, 디버깅 하기가 쉬워집니다.



## Webpack의 플러그인과 모듈은 어떤 역할들을 하나요?

로더가 자바스크립트나 JSON 파일 이외의 파일을 읽고 변환시키기 위해서 사용한다면, **플러그인**은 번들 최적화나 asset 관리, 환경변수 주입 같은 더 넓은 범위의 임무를 수행하는데 사용합니다.

플러그인을 사용하려면 플러그인을 `require()` 해야합니다. 그리고 `plugins` 배열에 추가합니다 대부분의 플러그인을 옵션을 사용해서 커스터마이징 할 수 있습니다. 각기 다른 목적으로 같은 플러그인을 여러 차례 사용할 수도 있기 때문에, new 생성자로 호출해서 인스턴스를 생성하여 사용합니다.

``` js
const HtmlWebpackPlugin = require('html-webpack-plugin');
const webpack = require('webpack');

module.exports = {
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({ template: './src/index.html' })
  ]
};
```

예를들어 위 예제에서 `html-webpack-plugin`은 만들어진 번들 파일을 자동으로 주입한 HTML 파일을 생성하는 역할을 합니다.

Webpack의 모듈은 다양한 언어와 전처리기를 처리해서 의존성을 번들에 포함시키는 역할을 합니다. 	

기본적으로 모듈은 전체 프로그램에서 분리된 chunk의 함수입니다. 모듈화를 잘 한다는 것은 프로그램의 어떤 영역을 목적성에 맞게 추상화 하고, 캡슐화 하는 것을 의미합니다. 그래서 각각의 모듈은 응집도 높은 디자인을 가지고, 애플리케이션 내에서 명백한 목적을 가집니다.

하지만 웹에서 모듈을 위한 지원이 늦기 때문에, 이를 보완해주는 여러가지 도구가 존재합니다. 그 중 하나가 웹팩이고, 웹팩의 경우에는 다양한 내장 로더를 통해서, 웹팩에게 모듈을 처리할 수 있는 방법을 설명해주고 해당 의존성을 번들에 포함시켜 줍니다.



### Webpack을 이용하여 HMR(Hot Module Replacement) 기능을 설정하려면 어떻게 해야 하나요?

webpack-dev-server의 옵션에 hot을 true로 주면, HMR 기능이 활성화 됩니다. 해당 속성을 키면 개발서버에서 전체 화면을 갱신하지 않고, 변경된 일부 모듈만 교체하게 됩니다.

