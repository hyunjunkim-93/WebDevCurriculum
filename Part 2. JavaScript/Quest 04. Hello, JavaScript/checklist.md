# Checklist

## 자바스크립트는 버전별로 어떻게 변화하고 발전해 왔을까요?

자바스크립트의 큰 줄기는 인터렉션과 인터렉션으로 인한 복잡도 증가에 따른 문법적 보완이라고 말하고 싶습니다.

기존의 웹은 문서를 표현하고 전달하기 위한 수단이었습니다.

이후에 웹이 발전하면서 오프라인 영역의 비즈니스를 웹에 접목하기 시작했습니다. 웹의 쓰임새가 다양화되면서 단순히 일방적인 정보전달에서 사용자와의 인터렉션이 중요해졌고, 인터렉션을 구현하기 위해 현재 자바스크립트라고 불리는 언어를 만들게 되었습니다. 

그리고 이 자바스크립트를 위한 표준을 ECMA라는 비영리 표준 기구에서 관리하고 있습니다.

초기의 간단한 인터렉션 구현의 목적과 다르게, 웹은 점점 온라인 산업의 중심 축으로 자리잡았습니다. 좀 더 복잡한 인터렉션에 대한 요구가 증가했고, 이에 따라서 자바스크립트나 관련 데이터 포맷 등이 발전하게 되었습니다. 

문법적인 취약점이나 기능상의 한계가 있던 자바스크립트는 이 요구를 수행하기 위해서 엄격한 rule을 적용하거나, 코드를 좀 더 효과적으로 작성하고 관리하기 위한 문법들이 추가되었습니다.

### 자바스크립트의 버전들을 가리키는 ES5, ES6, ES2016, ES2017 등은 무엇을 이야기할까요?



`ES5`는 2009년에 제정된 자바스크립트의 5번째 규격입니다.  주요 키워드는 `Strict Mode`, `JSON` 포맷 지원입니다.

Strict Mode는 엄격한 맥락에서 실행 맥락에서 자바스크립트 코드를 작동시키는 기능입니다. 원래 ES5는 ES3를 호환하지만, strict mode에서는 ES3에서 deprecated된 기능들은 사용할 수 없습니다. 코드를 엄격하게 검사해서 실수한 부부이 있다면 예외처리를 합니다. 자바스크립트기 때문에 가능한 안전하다고 보기 힘든 코드를 막아냅니다. 혼란스럽거나 좋지 않다고 여겨지는 기능들도 비활성화 시킵니다.

두 번째 큰 특징은 JSON 포맷의 지원입니다. JSON은 텍스트 형식으로 데이터를 저장하는 파일 포맷입니다. JavaScript에는 JSON 형식의 데이터를 다룰 수 있는 두 가지 메서드가 존재합니다. `JSON.parse`와 `JSON.stringify`를 이용해서 자바스크립트 객체로 변환하거나 JSON 타입으로 변환 시킬 수 있습니다.

이외에도 Object getter/setter나 배열 메서드인 map, filter, reduce 등이 ES5에서 추가됐습니다.

여섯번째 에디션인 `ES6`는 2015년에 제정됐으며, 후에 **ECMAScript2015**라는 이름으로 수정되었습니다. ES6에서는 전반적으로 큰 변화가 있었습니다. 복잡한 애플리케이션을 좀 더 견고하고 쉽게 작성할 수 있도록 여러가지 기능들이 추가되었습니다. 시기적으로도 6년만에 나온 새 표준이기 때문에 큰 차이가 있습니다.

이 시기가 본격적으로 복잡한 애플리케이션에 대비해서 자바스크립트를 개선한 시기라고 생각합니다. 아래와 같은 기능이 추가됐습니다.

1. 변수 선원 키워드 let, const

   함수 레벨 스코프이며, 재선언 재할당 가능한 var를 대체할 let과 const가 생겨났습니다

2. Module import / export

   애플리케이션이 커질 경우, 코드를 모듈로 나눠 효율적으로 관리할 수 있는 모듈 기능이 추가됐습니다

3. Promise

   흔히 말하는 콜백지옥이라는 사태를 피할 수 있는 비동기 처리 방법이 생겨났습니다

4. Arrow function

   일반 함수와는 다른 this 컨텍스트(자기 자신의 상위 스코프)를 가지고, 문법적으로 더 간단하게 표현할 수 있는 arrow function이 추가됐습니다

5. Iterator / Generator

   배열이나 유사 자료구조 내부를 순회할 수 있는 객체와 함수 실행 흐름을 통제하는 객체 추가

6. Classes

   함수와 프로토타입을 이용해서 타 언어의 클래스와 같은 형태의 코드를 작성할 수 있는 문법이 추가되었습니다

7. Object destructuring, Spread Operator 등

   데이터 할당을 더 편하게 할 수 있는 방법이 추가됐습니다

ECMA2016 ~ ECMA2017도 이러한 맥락으로 발전했습니다. 지수연산자나 배열의 include 메서드, promise 기반의 비동기 처리 방법인 async-await 등이 추가됩니다.

이후 버전도 코드 작성에서의 편의성을 지원하고, 불안전하다고 생각되는 문법적 약점들을 보완하는 방향이라고 생각합니다. 현재도 타 언어에서 강점으로 여겨지는 기능들을 적극적으로 검토하고 차용하고 있습니다.

<br>



## 웹 브라우저의 자바스크립트 콘솔은 어떻게 사용할까요?

### 웹 브라우저(Chrome)에서 자바스크립트 콘솔을 띄우는 단축키는 무엇인가요?

`Option + Command + i`를 입력해서 console을 띄울 수 있습니다. 

console은 현재 열린 문서를 기반으로 작동합니다. console로 찍힌 코드나 브라우저와 관련된 업데이트 사항 등 로그를 확인할 수 있습니다. 사용자가 직접 콘솔창에 코드를 입력하여 출력이 가능합니다. 이런 특성을 이용해 실제 소스코드에 `console.log()`를 입력하여 디버깅 용도로 사용할 수도 있습니다.

<br>



## `let`를 이용하여 변수를 선언하는 것과 `const`를 이용하여 변수를 선언하는 것은 어떻게 다를까요?

let은 값을 재할당 하는 것이 가능하지만, const는 상수처럼 재할당되지 않습니다. 두 키워드 모두 재선언 하는 것은 불가능합니다.

### `var`를 이용하여 선언하는 방법은 어떻게 다를까요?

var는 값 재할당과 변수 재선언, 둘 다 가능합니다. 그리고 let과 const가 블록 스코프를 가져서 중괄호 내부에서 선언하면, 그 중괄호 블락에서만 사용 가능한 것과 다르게, var 선언은 기존 선언을 덮어씌우거나 전역으로 평가됩니다.

그리고 var의 경우 호이스팅으로 선언이 끌어올려져 값은 할당돼있지 않지만 접근이 가능합니다. 반면에 let과 const는 호이스팅 되기는 하지만, temoral dead zone(let과 const 선언은 값이 평가되기 전까지 접근할 수 없다)라는 개념에 의해 접근할 수 없게 됩니다.

``` js
var a = 1;
var a = 2;
console.log(a);
// output: 7  **재선언과 재할당 모두 가능**

let b = 3;
let b = 4;
// output: Uncaught SyntaxError: Identifier 'b' has already been declared
// 재선언 불가능, 재할당 가능

const c = 5;
const c = 6;
// output: Uncaught SyntaxError: Identifier 'c' has already been declared

c = 6;
// output: Uncaught TypeError: Assignment to constant variable.
// 재선언과 재할당 모두 불가능
```



<br>



## 자바스크립트의 익명 함수는 무엇인가요?

익명 함수는 식별할 수 있는 이름 없이 선언된 함수입니다. 식별자는 해당 코드에 접근할 수 있는 기능을 하므로, 익명 함수의 경우 생성하고 나서는 접근할 수 없습니다. 이 익명함수를 여러 방법으로 활용할 수 있습니다.

자바스크립트에서의 함수 작성은 가장 크게 두 가지로 나뉩니다.

먼저 함수 선언식이라고 불리는 방법입니다.

``` js
function greeting() {
  alert('Hello!');
}
greeting();
```

일반적인 방법이고 함수의 본문까지 호이스팅 됩니다. 즉 작성한 함수가 전부 끌어올려지기 때문에, 작성한 순서와 상관없이 호출이 가능합니다.

다음은 함수 표현식이라고 불리는 익명함수를 활용한 방법입니다.

``` js
const greeting = function() {
  alert('Hello!');
};
```

함수를 값으로 취급해서 변수에 할당합니다. 변수 선언이기 때문에 함수의 평가 위치가 중요해집니다. 선언식과 다르게 변수에 함수를 할당하는 평가시점 전에, 해당 함수를 호출하게 되면 오류가 발생합니다.

다른 예시는 함수의 식별자를 정의해줄 필요가 없는 경우에 사용합니다.

함수의 인자로 사용하는 방법입니다:

``` js
setTimeout(function() {
  alert('Hello!')
}, 5000);
```

별도의 스코프를 생성해서 코드를 보호하고 바로 실행하고 싶다면, 익명함수를 이용한 즉시실행함수(IIFE)를 사용할 수 있습니다.

``` js
(function(){
  var greeting = prompt('인사 메시지를 입력해주세요');
  alert(greeting);
}())
```



### 자바스크립트의 Arrow Function은 무엇일까요?

화살표 함수는 함수를 작성하는 또 다른 방법입니다. 문법을 작성하는 모양새 외에도 기존 함수와 다른 특징이 있습니다.

우선 화살표 함수를 사용하면 내용이 작을 때 훨씬 축약된 형태로 함수를 작성할 수 있습니다.

``` js
const greeting = () => console.log('Hello!');
```

인자가 한 개 밖에 없는 경우 인자 괄호 없이 작성할 수도 있습니다.

``` js
const greeting = name => console.log(`Hello! ${name}`);
```

다른 중요한 특징으로 화살표 함수는 this를 가지지 않습니다. 이 말은 화살표 함수 내에서 this를 호출했을 때, this는 현재 컨텍스트 바로 상위 컨텍스트를 가리키게 됩니다. 그리고 this를 가지지 않기 때문에 생성자를 사용할 수 없습니다.

화살표 함수의 this는 정적으로 결정되기 때문에, 몇 가지 상황에서는 사용하지 않는 게 좋습니다.

예를들어 객체의 메서드로 화살표 함수를 사용하는 경우, 화살표 함수에서의 this는 해당 객체가 아닌 전역 객체를 가리키게 됨으로 의도와 빗나갈 수 있습니다.

``` js
const person = {
  name: 'jun',
  greeting: () => {
    console.log(`Hi, ${this.name}`);
  },
}

person.greeting();
// output: Hi, undefined
```

addEventListener 함수의 콜백함수로 사용할때도 화살표 함수는 전역 객체를 가리키기 때문에 의도와 빗나갈 수 있습니다. 원래 일반 함수로 정의된 함수는 addEventListener에서 바인딩된 타겟을 가리키는데, 만약 해당 이벤트의 this가 전역이 아닌 경우에는 원하는대로 동작하지 않게됩니다.

이처럼 this만 조금 유의해서 사용한다면, 더 간결하게 함수를 표현할 수 있습니다. 그리고 함수형 프로그래밍의 기법이나 커링 등을 표현하기에도 훨씬 좋은 가독성을 제공합니다.

 

